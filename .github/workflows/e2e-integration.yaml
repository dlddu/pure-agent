name: "CI: e2e integration (Level 2 — mock Argo)"
# DLD-466: Level ② e2e テスト (kind + Argo + mock-agent + mock-api)
#
# Level ① (BATS unit 테스트) 완료 후 push to main 시 실행됩니다.
# 실제 Claude Agent / Linear API 없이 kind + Argo Workflows 레이어를 검증합니다.
#
# 검증 항목:
#   1. Workflow 상태가 Succeeded인지
#   2. MCP daemon, LLM gateway daemon pod이 정상 기동했는지
#   3. continue-then-stop 시나리오에서 run-cycle 재귀가 2회 실행됐는지
#   4. depth-limit 시나리오에서 max_depth 종료가 Workflow 레벨에서 올바르게 처리되는지
#   5. Cleanup job 이후 /work가 비어있는지
#
# 모든 검증 테스트는 현재 skip 상태입니다 (DLD-466 구현 완료 후 활성화 예정).

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      scenario:
        description: "실행할 시나리오 (all 또는 시나리오명)"
        required: false
        default: "all"
        type: choice
        options:
          - "all"
          - "report-action"
          - "create-pr-action"
          - "none-action"
          - "continue-then-stop"
          - "depth-limit"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  CLUSTER_NAME: "pure-agent-e2e"
  ARGO_NAMESPACE: "argo"
  PURE_AGENT_NAMESPACE: "pure-agent"
  KIND_VERSION: "v0.22.0"
  ARGO_VERSION: "v3.6.4"
  YQ_VERSION: "v4.43.1"
  MOCK_AGENT_IMAGE: "pure-agent/mock-agent:e2e"
  MOCK_API_IMAGE: "pure-agent/mock-api:e2e"
  MOCK_GH_IMAGE: "pure-agent/mock-gh:e2e"

jobs:

  # ── Level 1 완료 대기 ────────────────────────────────────────────────────────
  # push to main 시 Level 1 (BATS + Vitest) 이 먼저 통과해야 Level 2가 실행됩니다.
  # workflow_dispatch 시에는 level-1-gate를 건너뜁니다.
  level-1-gate:
    name: "Wait for Level 1 CI"
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Wait for Level 1 workflows to succeed
        # Level 1 workflow들(ci-e2e-mock-components, ci-e2e-mock-api)이
        # 현재 커밋에서 성공했는지 확인합니다.
        # gh CLI로 동일 SHA의 check run 상태를 조회합니다.
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          SHA="${{ github.sha }}"
          echo "Waiting for Level 1 CI checks on SHA: $SHA"

          # 최대 10분 대기 (30초 간격으로 폴링)
          for i in $(seq 1 20); do
            # ci-e2e-mock-components 상태 확인
            MOCK_COMPONENTS_STATUS=$(gh api \
              "repos/${{ github.repository }}/commits/${SHA}/check-runs" \
              --jq '.check_runs[]
                    | select(.name | contains("mock components"))
                    | .conclusion' 2>/dev/null | head -1 || echo "pending")

            # ci-e2e-mock-api 상태 확인
            MOCK_API_STATUS=$(gh api \
              "repos/${{ github.repository }}/commits/${SHA}/check-runs" \
              --jq '.check_runs[]
                    | select(.name | contains("mock-api"))
                    | .conclusion' 2>/dev/null | head -1 || echo "pending")

            echo "Attempt ${i}/20 — mock-components: ${MOCK_COMPONENTS_STATUS}, mock-api: ${MOCK_API_STATUS}"

            if [[ "$MOCK_COMPONENTS_STATUS" == "success" && "$MOCK_API_STATUS" == "success" ]]; then
              echo "Level 1 checks passed."
              exit 0
            fi

            if [[ "$MOCK_COMPONENTS_STATUS" == "failure" || "$MOCK_API_STATUS" == "failure" ]]; then
              echo "Level 1 check failed — skipping Level 2."
              exit 1
            fi

            sleep 30
          done

          echo "Timed out waiting for Level 1 checks."
          exit 1

  # ── Level 2 E2E 테스트 ───────────────────────────────────────────────────────
  level-2:
    name: "Level 2 E2E (kind + Argo + mock)"
    runs-on: ubuntu-latest
    needs: [level-1-gate]
    # workflow_dispatch 시에는 level-1-gate가 없으므로 조건부로 실행
    if: always() && (needs.level-1-gate.result == 'success' || github.event_name == 'workflow_dispatch')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # ── Tool installation ──────────────────────────────────────────────────
      - name: Install dependencies (kind, kubectl, argo CLI, bats, jq, yq)
        run: |
          set -euo pipefail

          # kind
          sudo curl -Lo /usr/local/bin/kind \
            "https://kind.sigs.k8s.io/dl/${KIND_VERSION}/kind-linux-amd64"
          sudo chmod +x /usr/local/bin/kind

          # kubectl
          sudo curl -Lo /usr/local/bin/kubectl \
            "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo chmod +x /usr/local/bin/kubectl

          # argo CLI
          curl -sLO "https://github.com/argoproj/argo-workflows/releases/download/${ARGO_VERSION}/argo-linux-amd64.gz"
          gunzip argo-linux-amd64.gz
          chmod +x argo-linux-amd64
          sudo mv argo-linux-amd64 /usr/local/bin/argo

          # bats (Level 2 BATS 테스트 실행용)
          sudo apt-get update -q && sudo apt-get install -y -q bats jq curl

          # yq
          sudo curl -Lo /usr/local/bin/yq \
            "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
          sudo chmod +x /usr/local/bin/yq

      # ── kind 클러스터 생성 + Argo Workflows 설치 ───────────────────────────
      - name: Set up kind cluster and install Argo Workflows
        run: |
          bash e2e/lib/setup-kind.sh \
            --cluster-name "$CLUSTER_NAME"

      # ── mock 이미지 빌드 ────────────────────────────────────────────────────
      - name: Build mock-agent image
        run: |
          docker build \
            -t "$MOCK_AGENT_IMAGE" \
            e2e/mock-agent/

      - name: Build mock-api image
        run: |
          docker build \
            -t "$MOCK_API_IMAGE" \
            e2e/mock-api/

      - name: Build mock-gh image
        run: |
          docker build \
            -t "$MOCK_GH_IMAGE" \
            e2e/mock-gh/

      - name: Load mock images into kind cluster
        run: |
          kind load docker-image "$MOCK_AGENT_IMAGE" --name "$CLUSTER_NAME"
          kind load docker-image "$MOCK_API_IMAGE"   --name "$CLUSTER_NAME"
          kind load docker-image "$MOCK_GH_IMAGE"    --name "$CLUSTER_NAME"

      # ── router / export-handler 이미지 빌드 + 로드 ─────────────────────────
      # Level 2에서도 router / export-handler는 실제 이미지를 사용합니다.
      - name: Build router image
        uses: ./.github/actions/build-image
        with:
          service: router
          push: "false"

      - name: Build export-handler image
        uses: ./.github/actions/build-image
        with:
          service: export-handler
          push: "false"

      - name: Load service images into kind cluster
        run: |
          bash e2e/lib/setup-kind.sh \
            --cluster-name "$CLUSTER_NAME" \
            --images "ghcr.io/dlddu/pure-agent/router:latest,ghcr.io/dlddu/pure-agent/export-handler:latest"

      # ── Kubernetes 네임스페이스 + 시크릿 생성 ─────────────────────────────
      - name: Create namespace and secrets for pure-agent (mock values)
        run: |
          set -euo pipefail
          KUBE_CONTEXT="kind-${CLUSTER_NAME}"

          kubectl --context "$KUBE_CONTEXT" \
            create namespace "$PURE_AGENT_NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Level 2는 실제 API 키가 불필요하므로 더미 값을 사용합니다.
          kubectl --context "$KUBE_CONTEXT" -n "$PURE_AGENT_NAMESPACE" \
            create secret generic mcp-server-secrets \
              --from-literal=LINEAR_API_KEY="mock-linear-key" \
              --from-literal=LINEAR_TEAM_ID="mock-team-id" \
              --dry-run=client -o yaml | kubectl apply -f -

          kubectl --context "$KUBE_CONTEXT" -n "$PURE_AGENT_NAMESPACE" \
            create secret generic export-handler-secrets \
              --from-literal=LINEAR_API_KEY="mock-linear-key" \
              --from-literal=GITHUB_TOKEN="mock-gh-token" \
              --dry-run=client -o yaml | kubectl apply -f -

          kubectl --context "$KUBE_CONTEXT" -n "$PURE_AGENT_NAMESPACE" \
            create secret generic agent-secrets \
              --from-literal=CLAUDE_CODE_OAUTH_TOKEN="mock-claude-token" \
              --dry-run=client -o yaml | kubectl apply -f -

          kubectl --context "$KUBE_CONTEXT" -n "$PURE_AGENT_NAMESPACE" \
            create secret generic router-secrets \
              --from-literal=AWS_S3_BUCKET_NAME="mock-bucket" \
              --dry-run=client -o yaml | kubectl apply -f -

      # ── RBAC, ConfigMap, NetworkPolicy 적용 ───────────────────────────────
      - name: Apply K8s resources (RBAC, ConfigMap, NetworkPolicy)
        run: |
          set -euo pipefail
          KUBE_CONTEXT="kind-${CLUSTER_NAME}"

          kubectl --context "$KUBE_CONTEXT" \
            apply -n "$PURE_AGENT_NAMESPACE" -f k8s/rbac.yaml
          kubectl --context "$KUBE_CONTEXT" \
            apply -n "$PURE_AGENT_NAMESPACE" -f k8s/configmap.yaml
          kubectl --context "$KUBE_CONTEXT" \
            apply -n "$PURE_AGENT_NAMESPACE" -f k8s/network-policy.yaml

      # ── mock-gh ConfigMap 생성 ─────────────────────────────────────────────
      - name: Create mock-gh ConfigMap
        run: |
          set -euo pipefail
          KUBE_CONTEXT="kind-${CLUSTER_NAME}"
          kubectl --context "$KUBE_CONTEXT" -n "$PURE_AGENT_NAMESPACE" \
            create configmap mock-gh-bin \
              --from-file=gh=e2e/mock-gh/gh \
              --dry-run=client -o yaml | kubectl apply -f -

      # ── Level 2 mock WorkflowTemplate 적용 ────────────────────────────────
      # run-argo.sh --level 2 를 통해 mock 이미지로 패치된 WorkflowTemplate을 적용합니다.
      # 실제 시나리오 실행은 BATS 테스트에서 수행하므로 여기서는 템플릿 적용만 합니다.
      - name: Apply mock WorkflowTemplate (Level 2 patch)
        env:
          KUBE_CONTEXT: "kind-${{ env.CLUSTER_NAME }}"
          MOCK_AGENT_IMAGE: ${{ env.MOCK_AGENT_IMAGE }}
          MOCK_API_IMAGE: ${{ env.MOCK_API_IMAGE }}
          MOCK_GH_IMAGE: ${{ env.MOCK_GH_IMAGE }}
          NAMESPACE: ${{ env.PURE_AGENT_NAMESPACE }}
          # Level 2에서는 실제 API 키가 불필요하므로 더미 값으로 설정
          GITHUB_TEST_REPO: "mock-org/mock-repo"
        run: |
          set -euo pipefail
          # patch_workflow_template_for_mock 함수를 직접 호출하여 템플릿 적용
          # run-argo.sh를 --source-only로 로드하여 함수만 사용합니다.
          LEVEL=2 \
          SCENARIO=all \
          bash -c '
            source e2e/run-argo.sh --source-only
            src="k8s/workflow-template.yaml"
            dst="/tmp/workflow-template-level2.yaml"
            patch_workflow_template_for_mock "$src" "$dst" "level2-setup"
            apply_mock_workflow_template "$dst"
          '

      # ── Level 2 BATS テスト実行 ───────────────────────────────────────────
      - name: Run Level 2 Argo BATS tests
        env:
          KUBE_CONTEXT: "kind-${{ env.CLUSTER_NAME }}"
          NAMESPACE: ${{ env.PURE_AGENT_NAMESPACE }}
          WORKFLOW_TIMEOUT: "300"
        run: |
          bats e2e/lib/tests/argo-level2.bats

      - name: Run Level 2 E2E scenarios (run-argo.sh)
        env:
          KUBE_CONTEXT: "kind-${{ env.CLUSTER_NAME }}"
          NAMESPACE: ${{ env.PURE_AGENT_NAMESPACE }}
          MOCK_AGENT_IMAGE: ${{ env.MOCK_AGENT_IMAGE }}
          MOCK_API_IMAGE: ${{ env.MOCK_API_IMAGE }}
          MOCK_GH_IMAGE: ${{ env.MOCK_GH_IMAGE }}
          GITHUB_TEST_REPO: "mock-org/mock-repo"
        run: |
          bash e2e/run-argo.sh \
            --level 2 \
            --scenario "${{ github.event.inputs.scenario || 'all' }}" \
            --namespace "$PURE_AGENT_NAMESPACE" \
            --context "kind-$CLUSTER_NAME"

      # ── Teardown ─────────────────────────────────────────────────────────
      - name: Tear down kind cluster
        if: always()
        run: |
          kind delete cluster --name "$CLUSTER_NAME" || true
