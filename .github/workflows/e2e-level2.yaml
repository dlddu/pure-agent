name: "E2E: Level 2 (mock-agent + mock-api)"
# DLD-467: Level ② e2e 테스트 활성화
#
# Level ③ (e2e-full.yaml) 대비 주요 차이점:
#   - secrets 불필요 (LINEAR_API_KEY, GH_PAT, CLAUDE_CODE_OAUTH_TOKEN)
#   - 빌드 대상: mock-agent, mock-api 이미지만
#   - 실제 Claude Agent / Linear / GitHub API 호출 없음
#   - kind 클러스터에서 mock-api Deployment + Service를 배포하여 실행

on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:
    inputs:
      scenario:
        description: "실행할 시나리오 (all 또는 시나리오명)"
        required: false
        default: "all"
        type: choice
        options:
          - "all"
          - "continue-then-stop"
          - "depth-limit"
          - "create-pr-action"
          - "none-action"
          - "report-action"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  CLUSTER_NAME: "pure-agent-e2e-level2"
  ARGO_NAMESPACE: "argo"
  PURE_AGENT_NAMESPACE: "pure-agent"
  KIND_VERSION: "v0.22.0"
  ARGO_VERSION: "v3.6.4"
  YQ_VERSION: "v4.43.1"
  MOCK_AGENT_IMAGE: "ghcr.io/dlddu/pure-agent/e2e/mock-agent:latest"
  MOCK_API_IMAGE: "ghcr.io/dlddu/pure-agent/e2e/mock-api:latest"

jobs:
  e2e-level2:
    runs-on: ubuntu-24.04-arm

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # ── Tool installation ─────────────────────────────────────────────────
      - name: Install dependencies (kind, kubectl, argo CLI, jq, yq)
        run: |
          set -euo pipefail

          # kind
          sudo curl -Lo /usr/local/bin/kind \
            "https://kind.sigs.k8s.io/dl/${KIND_VERSION}/kind-linux-arm64"
          sudo chmod +x /usr/local/bin/kind

          # kubectl
          sudo curl -Lo /usr/local/bin/kubectl \
            "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/arm64/kubectl"
          sudo chmod +x /usr/local/bin/kubectl

          # argo CLI
          curl -sLO "https://github.com/argoproj/argo-workflows/releases/download/${ARGO_VERSION}/argo-linux-arm64.gz"
          gunzip argo-linux-arm64.gz
          chmod +x argo-linux-arm64
          sudo mv argo-linux-arm64 /usr/local/bin/argo

          # jq, curl (ubuntu에 포함되어 있으나 명시적 보장)
          sudo apt-get update -q && sudo apt-get install -y -q jq curl

          # yq (YAML 파싱용)
          sudo curl -Lo /usr/local/bin/yq \
            "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_arm64"
          sudo chmod +x /usr/local/bin/yq

      # ── Cluster setup ─────────────────────────────────────────────────────
      - name: Set up kind cluster and install Argo Workflows
        run: |
          bash e2e/lib/setup-kind.sh \
            --cluster-name "$CLUSTER_NAME"

      # ── Build mock images (Level ② 전용: mock-agent, mock-api のみ) ───────
      - name: Build mock-agent image
        uses: ./.github/actions/build-image
        with:
          service: e2e/mock-agent
          push: "false"

      - name: Build mock-api image
        uses: ./.github/actions/build-image
        with:
          service: e2e/mock-api
          push: "false"

      - name: Load mock images into kind cluster
        run: |
          bash e2e/lib/setup-kind.sh \
            --cluster-name "$CLUSTER_NAME" \
            --images "${MOCK_AGENT_IMAGE},${MOCK_API_IMAGE}"

      # ── Kubernetes namespace setup ────────────────────────────────────────
      - name: Create namespace for pure-agent (Level 2)
        run: |
          set -euo pipefail
          kubectl --context "kind-${CLUSTER_NAME}" create namespace "$PURE_AGENT_NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Level ② 用ダミーシークレット (mock なので実際の値は不要)
          kubectl --context "kind-${CLUSTER_NAME}" -n "$PURE_AGENT_NAMESPACE" \
            create secret generic mcp-server-secrets \
              --from-literal=LINEAR_API_KEY="mock-key" \
              --from-literal=LINEAR_TEAM_ID="mock-team" \
              --dry-run=client -o yaml | kubectl apply -f -

          kubectl --context "kind-${CLUSTER_NAME}" -n "$PURE_AGENT_NAMESPACE" \
            create secret generic export-handler-secrets \
              --from-literal=LINEAR_API_KEY="mock-key" \
              --from-literal=GITHUB_TOKEN="mock-token" \
              --dry-run=client -o yaml | kubectl apply -f -

          kubectl --context "kind-${CLUSTER_NAME}" -n "$PURE_AGENT_NAMESPACE" \
            create secret generic agent-secrets \
              --from-literal=CLAUDE_CODE_OAUTH_TOKEN="mock-token" \
              --dry-run=client -o yaml | kubectl apply -f -

          kubectl --context "kind-${CLUSTER_NAME}" -n "$PURE_AGENT_NAMESPACE" \
            create secret generic router-secrets \
              --from-literal=AWS_S3_BUCKET_NAME="mock-bucket" \
              --dry-run=client -o yaml | kubectl apply -f -

      # ── Deploy mock-api as a Service in the cluster ───────────────────────
      - name: Deploy mock-api Deployment and Service
        run: |
          set -euo pipefail
          cat <<EOF | kubectl --context "kind-${CLUSTER_NAME}" apply -n "$PURE_AGENT_NAMESPACE" -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mock-api
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: mock-api
            template:
              metadata:
                labels:
                  app: mock-api
              spec:
                containers:
                  - name: mock-api
                    image: ${MOCK_API_IMAGE}
                    imagePullPolicy: IfNotPresent
                    ports:
                      - containerPort: 4000
                    env:
                      - name: PORT
                        value: "4000"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: mock-api
          spec:
            selector:
              app: mock-api
            ports:
              - port: 4000
                targetPort: 4000
          EOF

          kubectl --context "kind-${CLUSTER_NAME}" \
            -n "$PURE_AGENT_NAMESPACE" \
            rollout status deployment/mock-api --timeout=60s

      # ── Apply K8s resources ────────────────────────────────────────────────
      - name: Apply K8s resources (RBAC, ConfigMap, NetworkPolicy)
        run: |
          set -euo pipefail
          kubectl --context "kind-${CLUSTER_NAME}" \
            apply -n "$PURE_AGENT_NAMESPACE" -f k8s/rbac.yaml
          kubectl --context "kind-${CLUSTER_NAME}" \
            apply -n "$PURE_AGENT_NAMESPACE" -f k8s/configmap.yaml
          kubectl --context "kind-${CLUSTER_NAME}" \
            apply -n "$PURE_AGENT_NAMESPACE" -f k8s/network-policy.yaml

      # ── Apply WorkflowTemplate (mock-agent + mock-router 用パッチ) ────────
      - name: Apply Argo WorkflowTemplate (patched for Level 2)
        run: |
          set -euo pipefail

          cp k8s/workflow-template.yaml /tmp/workflow-template-level2.yaml

          # kind 호환 패치: storageClassName, accessMode, nodeSelector, tolerations
          sed -i 's/storageClassName: efs/storageClassName: standard/' \
            /tmp/workflow-template-level2.yaml
          sed -i 's/ReadWriteMany/ReadWriteOnce/' \
            /tmp/workflow-template-level2.yaml
          yq -i 'del(.spec.templates[].nodeSelector)' \
            /tmp/workflow-template-level2.yaml
          yq -i 'del(.spec.templates[].tolerations)' \
            /tmp/workflow-template-level2.yaml

          # imagePullPolicy: IfNotPresent (kind ローカル画像)
          yq -i '(.spec.templates[] | select(has("container")) | .container.imagePullPolicy) = "IfNotPresent"' \
            /tmp/workflow-template-level2.yaml

          # mock-agent 이미지로 claude-agent 이미지를 대체
          yq -i "(.spec.templates[] | select(.name == \"agent-job\") | .container.image) = \"${MOCK_AGENT_IMAGE}\"" \
            /tmp/workflow-template-level2.yaml

          # mock-agent 엔트리포인트 패치: /home/claude/entrypoint.sh → /app/entrypoint.sh
          yq -i '(.spec.templates[] | select(.name == "agent-job") | .container.command) = ["/app/entrypoint.sh"]' \
            /tmp/workflow-template-level2.yaml

          # mock-agent에 SCENARIO_DIR 환경변수 주입 (ConfigMap 마운트 경로)
          yq -i '(.spec.templates[] | select(.name == "agent-job") | .container.env) += [{"name": "SCENARIO_DIR", "value": "/scenario"}]' \
            /tmp/workflow-template-level2.yaml

          # scenario_configmap 파라미터 추가 (기본값: scenario-default)
          yq -i '.spec.arguments.parameters += [{"name": "scenario_configmap", "value": "scenario-default"}]' \
            /tmp/workflow-template-level2.yaml

          # Workflow 최상위에 scenario-data 볼륨 추가 (ConfigMap 기반)
          yq -i '.spec.volumes = [{"name": "scenario-data", "configMap": {"name": "{{workflow.parameters.scenario_configmap}}", "optional": true}}]' \
            /tmp/workflow-template-level2.yaml

          # agent-job에 scenario-data 볼륨 마운트 추가
          yq -i '(.spec.templates[] | select(.name == "agent-job") | .container.volumeMounts) += [{"name": "scenario-data", "mountPath": "/scenario", "readOnly": true}]' \
            /tmp/workflow-template-level2.yaml

          # ── mock-router 패치 ──────────────────────────────────────────────
          # 실제 router 바이너리는 export_config.actions에 "continue"가 있으면
          # depth/max_depth를 무시하고 항상 continue를 반환합니다.
          # Level 2에서는 depth >= max_depth - 1 이면 항상 stop하는 mock router로 교체합니다.

          # router 이미지를 alpine으로 교체 (실제 router 바이너리 사용하지 않음)
          yq -i '(.spec.templates[] | select(.name == "router") | .container.image) = "alpine:3.20"' \
            /tmp/workflow-template-level2.yaml

          # router에 depth/max_depth를 환경변수로 주입 (Argo 템플릿 파라미터 → 환경변수)
          yq -i '(.spec.templates[] | select(.name == "router") | .container.env) += [{"name": "ROUTER_DEPTH", "value": "{{inputs.parameters.depth}}"}, {"name": "ROUTER_MAX_DEPTH", "value": "{{inputs.parameters.max_depth}}"}]' \
            /tmp/workflow-template-level2.yaml

          # router의 args를 mock-router 셸 스크립트로 교체
          # depth >= max_depth - 1 이면 stop, 그렇지 않으면 export_config 확인
          cat > /tmp/mock-router-script.sh <<'MOCK_ROUTER'
          DEPTH="${ROUTER_DEPTH}"
          MAX_DEPTH="${ROUTER_MAX_DEPTH}"
          OUTPUT="/tmp/continue.txt"
          echo "[mock-router] depth=$DEPTH max_depth=$MAX_DEPTH" >&2
          if [ "$DEPTH" -ge "$((MAX_DEPTH - 1))" ]; then
            echo "[mock-router] depth limit reached ($DEPTH >= $MAX_DEPTH - 1) -> stop" >&2
            echo "false" > "$OUTPUT"
          else
            CONFIG="$EXPORT_CONFIG_JSON"
            if echo "$CONFIG" | grep -q '"continue"'; then
              echo "[mock-router] continue action found -> continue" >&2
              echo "true" > "$OUTPUT"
            else
              echo "[mock-router] no continue action -> stop" >&2
              echo "false" > "$OUTPUT"
            fi
          fi
          MOCK_ROUTER
          MOCK_ROUTER_SCRIPT=$(cat /tmp/mock-router-script.sh)
          yq -i "(.spec.templates[] | select(.name == \"router\") | .container.args) = [\"$MOCK_ROUTER_SCRIPT\"]" \
            /tmp/workflow-template-level2.yaml

          # mock-api URL을 환경 변수로 주입
          yq -i "(.spec.templates[] | select(has(\"container\")) | .container.env) += [{\"name\": \"MOCK_API_URL\", \"value\": \"http://mock-api.${PURE_AGENT_NAMESPACE}.svc.cluster.local:4000\"}]" \
            /tmp/workflow-template-level2.yaml

          # scenario-default 빈 ConfigMap 생성 (워크플로우 볼륨 기본값)
          kubectl --context "kind-${CLUSTER_NAME}" -n "$PURE_AGENT_NAMESPACE" \
            create configmap scenario-default --dry-run=client -o yaml | \
            kubectl apply -f -

          kubectl --context "kind-${CLUSTER_NAME}" \
            apply -n "$PURE_AGENT_NAMESPACE" -f /tmp/workflow-template-level2.yaml

      # ── Run Level 2 E2E scenarios ─────────────────────────────────────────
      - name: Run Level 2 E2E scenarios (run-argo.sh --level 2)
        env:
          KUBE_CONTEXT: "kind-${{ env.CLUSTER_NAME }}"
          MOCK_AGENT_IMAGE: ${{ env.MOCK_AGENT_IMAGE }}
          MOCK_API_URL: "http://mock-api.${{ env.PURE_AGENT_NAMESPACE }}.svc.cluster.local:4000"
        run: |
          bash e2e/run-argo.sh \
            --level 2 \
            --scenario "${{ github.event.inputs.scenario || 'all' }}" \
            --namespace "$PURE_AGENT_NAMESPACE" \
            --context "kind-${CLUSTER_NAME}"

      # ── Teardown ──────────────────────────────────────────────────────────
      - name: Tear down kind cluster
        if: always()
        run: |
          kind delete cluster --name "$CLUSTER_NAME" || true
